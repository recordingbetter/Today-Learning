
# 자료구조
- 데이터를 어떤 구조로 저장하고 탐색해야하는가

1. Insert : 데이터를 어떻게 저장할 것인가
2. Search : 데이터를 어떻게 탐색할 것인가
3. Delete : 데이터를 어떻게 삭제할 것인가

# 알고리즘
- 문제를 해결하는 방법론




### 자료구조의 알고리즘
- 데이터를 저장하고 탐색하는 방법에 대한 고민들

### 자료구조를 이용한 알고리즘
- 자료구조를 이용해 어떤문제를 해결하는 것


# Array & Linked List

### 배열
- 동일한 자료형을 가진 데이터의 모임
- 가변 배열이라해도 크기가 고정되어있음
- 길이를 늘리려면, 적절한 공간을 찾아 기존 값을 복사하고 늘어나는 부분에 데이터를 넣는다.
- 값을 찾을때에는 인덱스로 바로 접근
- 데이터의 추가, 삭제가 빈번하지 않으나 데이터의 접근이 빈번할때 사용

### Linked List
- 길이를 늘릴때에는 뒤에 노드만 추가
- 값을 찾을때에는 처음 노드부터 따라가서 찾을 수 있다.
- 데이터를 자주 추가하고 삭제할때 사용


# 재귀함수 (recursion)
- 함수 정의 내에 같은 함수를 다시 호출하는 방법
- 탈출 조건이 필요하다.

#### stack frame : 공부해야함

### 피보나치

```python
def fibo(n):
    if n == 0 or n == 1:
        return 1
    return fibo(n-2) + fibo(n-1)

if __name__ == "__main__":
    n = 10
    for i in range(n):
        print(fibo(i), end='    ')
```

```python
# generator 사용
def fibo_gen(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

if __name__ == "__main__":
    f = fibo_gen(10)
    for i in range(10):
        print(next(f), end="    ")
```    

#### generator
- lazy 게으른 연산, 요구를 할때에만 값을 반환한다. 처음부터 가지고 있지 않음.
- iterator 종류 중 하나

#### 코루틴까지 공부하기

### 하노이의 탑

```python
def hanoi(num, _from, _by, _to):
    # 탈출조건
    if num == 1:
        print("{}에서 {}로 {}번째 원반 이동".format(_from, _to, num))
        return
    hanoi(num - 1, _from, _to, _by)
    print("{}에서 {}로 {}번째 원반 이동".format(_from, _to, num))
    hanoi(num - 1, _by, _from, _to)


if __name__ == "__main__":
    while 1:
        numOfTray = int(input("원반의 갯수를 입력하세요(종료:0) :"))
        if numOfTray == 0:
            break
        hanoi(numOfTray, 'A', 'B', 'C')
```
    
    
## Liner Search (선형 탐색)
- 순차적으로 탐색
- 탐색 속도 비교군
- T(n) = n
- 이 알고리즘은 최악의 경우에도 n의 시간을 보장한다.
- big O : n

```python
def liner_search(data, target):
    for idx in range(len(data)):
        if data[idx] == target:
            return idx
        return None


if __name__ == "__main__":
    data = [i for i in range(10)]
    target = 4
    idx = liner_search(data, target)

    if idx is None:
        print("{}이 존재하지 않습니다.".format(target))
    else:
        print("찾는 데이터의 인덱스는 {}이고 데이터는 {}입니다.".format(idx, data[idx]))
```

## Binary Search (이진 탐색)
- liner search에 비해 성능이 좋다.
- 이진 탐색은 데이터가 정렬된 상태에서만 작동한다.
- 이 알고리즘은 최악의 경우에도 logn의 시간을 보장한다.
- big O : logn


```python
def binary_search(data, target):
    """
    데이터가 정렬된 상태로 전달되어야 합니다.
    :param data: sorted list
    :param target: 찾는 숫자
    :return: 찾는 숫자의 인덱스
    """
    start = 0
    end = len(data) - 1
    count = 0
    while start <= end:

        mid = (start + end) // 2
        # target 과 mid 값이 같을 경우
        if target == data[mid]:
            count += 1
            return mid, count
        # target 이 중간값보다 작을 경우
        elif target < data[mid]:
            count += 1
            # end를 중간값 바로 전으로 이동
            end = mid - 1
        # target 이 중간값보다 작을 경우
        else:
            count += 1
            # start 를 중간값 다음으로 이동
            start = mid + 1
    # while 을 빠져나가는 경우는 end 와 start 가 교차되었을때
    return None


if __name__ == '__main__':
    li = [i for i in range(100)]
    target = 96
    idx = binary_search(li, target)
    if idx:
        print(li[idx[0]])
        print("{}번만에 찾았습니다.".format(idx[1]))
    else:
        print("There's no data")
```

#### 이진 탐색은 데이터가 정렬된 상태에서만 작동한다.

- while로 해결할 수 있으면 있으면 재귀함수를 안쓰는 것이 좋다.
- 재귀함수는 가급적 안쓰는 것이 좋다.

#### 과제 : Binary Search를 재귀함수로 바꾸기, 버블정렬 

```
# Binary Search를 재귀함수로 바꾸기
def binary_search_re(start, end, target):
    lst = [i for i in range(start, end + 1)]
    mid = len(lst) // 2
    num = lst[mid]
    if start > end:
        return 1
    elif target == num:
        return num
    elif target < num:
        return binary_search_re(start, lst[mid - 1], target)
    else:
        return binary_search_re(lst[mid + 1], end, target)


if __name__ == '__main__':
    start = 1
    end = 11
    target = 2
    result = binary_search_re(start, end, target)
    if result:
        print(result)
    else:
        print("There's no data.")
```

```
# 버블정렬 (for 문을 2개 사용하면 Big O = n^2)
def bubble(lst):
    lst_len = len(lst)
    for i in range(lst_len - 1):
        for j in range(0, lst_len - i - 1):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    return lst


if __name__ == "__main__":
    list1 = [4, 7, 9, 3, 4, 6, 2, 7, 1]
    print(bubble(list1))
```

- 버블정렬의 Big O는 등차수열로 계산하면 n^2이 나온다.
- for를 중첩하는 것은 가급적 피해야한다.

## Big O (시간 복잡도)

- O(1)
- O(n)
- O(logn)
- O(nlogn)
- O(n^2)

### 추상자료형 (ADT Abstract Data Type)

- 함수 인터페이스 목록
- 구현 방법을 명시하고 있지 않다

#### 함수 인터페이스

- 함수이름 + 인자목록 + 반환값 + 설명을 명시해 놓은 것
- 이것을 알면 함수를 사용할 수 있게 함.
- help(list.sort)
- doc string이랑 비슷(같..)하다. 자료구조에서 부르는 이름.

# Liked List!!!!

- 중요!!!
- 자료구조의 시작이자 끝

### node

- 데이터를 담아두는 하나의 틀 (데이터부 + 다음 노드를 가리키는 참조부)

#### ADT (07_linked_list.py)

- 가정 :data로 None을 넣을 수 없음
- 예외 처리가 없으므로 제작자의 의도대로만 사용해야함.

1. append(data) -> None
2. empty() -> bool
	- 비어있으면 True
	- 비어있지않으면 False
3. size() -> integer
4. traverse(mode = 'next') -> data ('first':첫번째 node, 'next':첫번째 이후의 다음 node로 순회하며 반환)
5. remove() -> data (traverse를 통해 찾은 삭제 node를 삭제하고 삭제하는 node를 반환)


### 레퍼런스 카운팅

- 레퍼런스 카운트 : 데이터를 참조하고 있는 숫자. 0이면 아무데서도 쓰이는 곳이 없다는 의미 -> 가비지 콜렉션

```
>>> import sys
>>> sys.getrefcount()
>>> help(sys.getrefcount)
getrefcount(...)
    getrefcount(object) -> integer

    Return the reference count of object.  The count returned is generally
    one higher than you might expect, because it includes the (temporary)
    reference as an argument to getrefcount().
```
    
### OOP

#### 생성자 (constructor)

- 객체를 만들때 반드시 1번은 호출한다.
- \_\_init\_\_


#### 소멸자 (destructor)

- 객체를 메모리 공간에서 삭제될때 반드시 1번은 호출한다.
- \_\_del\_\_
- 파이썬은 garbage collection을 하기 때문에 쓸 일은 별로 없다.

#### heap

- 프로그래머 마음대로 메모리를 할당하고, 스코프가 끝나지 않더라도 메모리에서 삭제할 수 있다.
- 할당된 메모리가 삭제되는 것을 보장하지 않음. (memory leak 발생 가능)
- 인터프리터 언어(파이썬 등)는 stack에 메모리에 할당 못함. heap에 할당함.
- private heap : 파이썬이 실행되면서 할당하는 메모리 영역. 이 영역 내부를 나눠서 사용한다.

- 컴파일러 언어는 메모리의 모든 영역을 다 사용 (code, data, heap, stack)

- 파이썬 - compiler - lexer / parser
- 참고 : import ast(lexer에서 parser 넘어가는 중간단계)








과제 : dummy linked list 구현







tree
binary tree
binary search tree
AVL(알면 좋다)





