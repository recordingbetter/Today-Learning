
# 자료구조
- 데이터를 어떤 구조로 저장하고 탐색해야하는가

1. Insert : 데이터를 어떻게 저장할 것인가
2. Search : 데이터를 어떻게 탐색할 것인가
3. Delete : 데이터를 어떻게 삭제할 것인가

# 알고리즘
- 문제를 해결하는 방법론




### 자료구조의 알고리즘
- 데이터를 저장하고 탐색하는 방법에 대한 고민들

### 자료구조를 이용한 알고리즘
- 자료구조를 이용해 어떤문제를 해결하는 것


# Array & Linked List

### 배열
- 동일한 자료형을 가진 데이터의 모임
- 가변 배열이라해도 크기가 고정되어있음
- 길이를 늘리려면, 적절한 공간을 찾아 기존 값을 복사하고 늘어나는 부분에 데이터를 넣는다.
- 값을 찾을때에는 인덱스로 바로 접근
- 데이터의 추가, 삭제가 빈번하지 않으나 데이터의 접근이 빈번할때 사용

### Linked List
- 길이를 늘릴때에는 뒤에 노드만 추가
- 값을 찾을때에는 처음 노드부터 따라가서 찾을 수 있다.
- 데이터를 자주 추가하고 삭제할때 사용


# 재귀함수 (recursion)
- 함수 정의 내에 같은 함수를 다시 호출하는 방법
- 탈출 조건이 필요하다.

#### stack frame : 공부해야함

### 피보나치

```python
def fibo(n):
    if n == 0 or n == 1:
        return 1
    return fibo(n-2) + fibo(n-1)

if __name__ == "__main__":
    n = 10
    for i in range(n):
        print(fibo(i), end='    ')
```

```python
# generator 사용
def fibo_gen(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

if __name__ == "__main__":
    f = fibo_gen(10)
    for i in range(10):
        print(next(f), end="    ")
```    

#### generator
- lazy 게으른 연산, 요구를 할때에만 값을 반환한다. 처음부터 가지고 있지 않음.
- iterator 종류 중 하나

#### 코루틴까지 공부하기

### 하노이의 탑

```python
def hanoi(num, _from, _by, _to):
    # 탈출조건
    if num == 1:
        print("{}에서 {}로 {}번째 원반 이동".format(_from, _to, num))
        return
    hanoi(num - 1, _from, _to, _by)
    print("{}에서 {}로 {}번째 원반 이동".format(_from, _to, num))
    hanoi(num - 1, _by, _from, _to)


if __name__ == "__main__":
    while 1:
        numOfTray = int(input("원반의 갯수를 입력하세요(종료:0) :"))
        if numOfTray == 0:
            break
        hanoi(numOfTray, 'A', 'B', 'C')
```
    
    
## Liner Search (선형 탐색)
- 순차적으로 탐색
- 탐색 속도 비교군
- T(n) = n
- 이 알고리즘은 최악의 경우에도 n의 시간을 보장한다.
- big O : n

```python
def liner_search(data, target):
    for idx in range(len(data)):
        if data[idx] == target:
            return idx
        return None


if __name__ == "__main__":
    data = [i for i in range(10)]
    target = 4
    idx = liner_search(data, target)

    if idx is None:
        print("{}이 존재하지 않습니다.".format(target))
    else:
        print("찾는 데이터의 인덱스는 {}이고 데이터는 {}입니다.".format(idx, data[idx]))
```

## Binary Search (이진 탐색)
- liner search에 비해 성능이 좋다.
- 이진 탐색은 데이터가 정렬된 상태에서만 작동한다.
- 이 알고리즘은 최악의 경우에도 logn의 시간을 보장한다.
- big O : logn


```python
def binary_search(data, target):
    """
    데이터가 정렬된 상태로 전달되어야 합니다.
    :param data: sorted list
    :param target: 찾는 숫자
    :return: 찾는 숫자의 인덱스
    """
    start = 0
    end = len(data) - 1
    count = 0
    while start <= end:

        mid = (start + end) // 2
        # target 과 mid 값이 같을 경우
        if target == data[mid]:
            count += 1
            return mid, count
        # target 이 중간값보다 작을 경우
        elif target < data[mid]:
            count += 1
            # end를 중간값 바로 전으로 이동
            end = mid - 1
        # target 이 중간값보다 작을 경우
        else:
            count += 1
            # start 를 중간값 다음으로 이동
            start = mid + 1
    # while 을 빠져나가는 경우는 end 와 start 가 교차되었을때
    return None


if __name__ == '__main__':
    li = [i for i in range(100)]
    target = 96
    idx = binary_search(li, target)
    if idx:
        print(li[idx[0]])
        print("{}번만에 찾았습니다.".format(idx[1]))
    else:
        print("There's no data")
```

#### 이진 탐색은 데이터가 정렬된 상태에서만 작동한다.



과제 : Binary Search를 재귀함수로 바꾸기, 버블정렬 


## Big O (시간 복잡도)

- O(1)
- O(n)
- O(logn)
- O(nlogn)
- O(n^2)


tree
binary tree
binary search tree
AVL(알면 좋다)





