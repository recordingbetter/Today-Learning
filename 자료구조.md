
# 자료구조
- 데이터를 어떤 구조로 저장하고 탐색해야하는가

1. Insert : 데이터를 어떻게 저장할 것인가
2. Search : 데이터를 어떻게 탐색할 것인가
3. Delete : 데이터를 어떻게 삭제할 것인가

# 알고리즘
- 문제를 해결하는 방법론

### 자료구조의 알고리즘
- 데이터를 저장하고 탐색하는 방법에 대한 고민들

### 자료구조를 이용한 알고리즘
- 자료구조를 이용해 어떤문제를 해결하는 것


# Array & Linked List

### 배열

- 동일한 자료형을 가진 데이터의 모임
- 가변 배열이라해도 크기가 고정되어있음
- 길이를 늘리려면, 적절한 공간을 찾아 기존 값을 복사하고 늘어나는 부분에 데이터를 넣는다.
- 값을 찾을때에는 인덱스로 바로 접근
- 데이터의 추가, 삭제가 빈번하지 않으나 데이터의 접근이 빈번할때 사용

### Linked List

- 길이를 늘릴때에는 뒤에 노드만 추가
- 값을 찾을때에는 처음 노드부터 따라가서 찾을 수 있다.
- 데이터를 자주 추가하고 삭제할때 사용


# 재귀함수 (recursion)

- 함수 정의 내에 같은 함수를 다시 호출하는 방법
- 탈출 조건이 필요하다.

#### stack frame : 공부해야함

### 피보나치

```python
def fibo(n):
    if n == 0 or n == 1:
        return 1
    return fibo(n-2) + fibo(n-1)

if __name__ == "__main__":
    n = 10
    for i in range(n):
        print(fibo(i), end='    ')
```

```python
# generator 사용
def fibo_gen(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

if __name__ == "__main__":
    f = fibo_gen(10)
    for i in range(10):
        print(next(f), end="    ")
```    

#### generator
- lazy 게으른 연산, 요구를 할때에만 값을 반환한다. 처음부터 가지고 있지 않음.
- iterator 종류 중 하나

#### 코루틴까지 공부하기

### 하노이의 탑

```python
def hanoi(num, _from, _by, _to):
    # 탈출조건
    if num == 1:
        print("{}에서 {}로 {}번째 원반 이동".format(_from, _to, num))
        return
    hanoi(num - 1, _from, _to, _by)
    print("{}에서 {}로 {}번째 원반 이동".format(_from, _to, num))
    hanoi(num - 1, _by, _from, _to)


if __name__ == "__main__":
    while 1:
        numOfTray = int(input("원반의 갯수를 입력하세요(종료:0) :"))
        if numOfTray == 0:
            break
        hanoi(numOfTray, 'A', 'B', 'C')
```
    
    
## Liner Search (선형 탐색)
- 순차적으로 탐색
- 탐색 속도 비교군
- T(n) = n
- 이 알고리즘은 최악의 경우에도 n의 시간을 보장한다.
- big O : n

```python
def liner_search(data, target):
    for idx in range(len(data)):
        if data[idx] == target:
            return idx
        return None


if __name__ == "__main__":
    data = [i for i in range(10)]
    target = 4
    idx = liner_search(data, target)

    if idx is None:
        print("{}이 존재하지 않습니다.".format(target))
    else:
        print("찾는 데이터의 인덱스는 {}이고 데이터는 {}입니다.".format(idx, data[idx]))
```

## Binary Search (이진 탐색)
- liner search에 비해 성능이 좋다.
- 이진 탐색은 데이터가 정렬된 상태에서만 작동한다.
- 이 알고리즘은 최악의 경우에도 logn의 시간을 보장한다.
- big O : logn


```python
def binary_search(data, target):
    """
    데이터가 정렬된 상태로 전달되어야 합니다.
    :param data: sorted list
    :param target: 찾는 숫자
    :return: 찾는 숫자의 인덱스
    """
    start = 0
    end = len(data) - 1
    count = 0
    while start <= end:

        mid = (start + end) // 2
        # target 과 mid 값이 같을 경우
        if target == data[mid]:
            count += 1
            return mid, count
        # target 이 중간값보다 작을 경우
        elif target < data[mid]:
            count += 1
            # end를 중간값 바로 전으로 이동
            end = mid - 1
        # target 이 중간값보다 작을 경우
        else:
            count += 1
            # start 를 중간값 다음으로 이동
            start = mid + 1
    # while 을 빠져나가는 경우는 end 와 start 가 교차되었을때
    return None


if __name__ == '__main__':
    li = [i for i in range(100)]
    target = 96
    idx = binary_search(li, target)
    if idx:
        print(li[idx[0]])
        print("{}번만에 찾았습니다.".format(idx[1]))
    else:
        print("There's no data")
```

#### 이진 탐색은 데이터가 정렬된 상태에서만 작동한다.

- while로 해결할 수 있으면 있으면 재귀함수를 안쓰는 것이 좋다.
- 재귀함수는 가급적 안쓰는 것이 좋다.

#### 과제 : Binary Search를 재귀함수로 바꾸기, 버블정렬 

```
# Binary Search를 재귀함수로 바꾸기
def binary_search_re(start, end, target):
    lst = [i for i in range(start, end + 1)]
    mid = len(lst) // 2
    num = lst[mid]
    if start > end:
        return 1
    elif target == num:
        return num
    elif target < num:
        return binary_search_re(start, lst[mid - 1], target)
    else:
        return binary_search_re(lst[mid + 1], end, target)


if __name__ == '__main__':
    start = 1
    end = 11
    target = 2
    result = binary_search_re(start, end, target)
    if result:
        print(result)
    else:
        print("There's no data.")
```

```
# 버블정렬 (for 문을 2개 사용하면 Big O = n^2)
def bubble(lst):
    lst_len = len(lst)
    for i in range(lst_len - 1):
        for j in range(0, lst_len - i - 1):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    return lst


if __name__ == "__main__":
    list1 = [4, 7, 9, 3, 4, 6, 2, 7, 1]
    print(bubble(list1))
```

- 버블정렬의 Big O는 등차수열로 계산하면 n^2이 나온다.
- for를 중첩하는 것은 가급적 피해야한다.

## Big O (시간 복잡도)

- O(1)
- O(n)
- O(logn)
- O(nlogn)
- O(n^2)

### 추상자료형 (ADT Abstract Data Type)

- 함수 인터페이스 목록
- 구현 방법을 명시하고 있지 않다

#### 함수 인터페이스

- 함수이름 + 인자목록 + 반환값 + 설명을 명시해 놓은 것
- 이것을 알면 함수를 사용할 수 있게 함.
- help(list.sort)
- doc string이랑 비슷(같..)하다. 자료구조에서 부르는 이름.

# Liked List!!!!

- 중요!!!
- 자료구조의 시작이자 끝

### node

- 데이터를 담아두는 하나의 틀 (데이터부 + 다음 노드를 가리키는 참조부)

#### ADT (07_linked_list.py)

- 가정 :data로 None을 넣을 수 없음
- 예외 처리가 없으므로 제작자의 의도대로만 사용해야함.

1. append(data) -> None
2. empty() -> bool
	- 비어있으면 True
	- 비어있지않으면 False
3. size() -> integer
4. traverse(mode = 'next') -> data ('first':첫번째 node, 'next':첫번째 이후의 다음 node로 순회하며 반환)
5. remove() -> data (traverse를 통해 찾은 삭제 node를 삭제하고 삭제하는 node를 반환)


### 레퍼런스 카운팅

- 레퍼런스 카운트 : 데이터를 참조하고 있는 숫자. 0이면 아무데서도 쓰이는 곳이 없다는 의미 -> 가비지 콜렉션

```
>>> import sys
>>> sys.getrefcount()
>>> help(sys.getrefcount)
getrefcount(...)
    getrefcount(object) -> integer

    Return the reference count of object.  The count returned is generally
    one higher than you might expect, because it includes the (temporary)
    reference as an argument to getrefcount().
```
    
### OOP

#### 생성자 (constructor)

- 객체를 만들때 반드시 1번은 호출한다.
- \_\_init\_\_


#### 소멸자 (destructor)

- 객체를 메모리 공간에서 삭제될때 반드시 1번은 호출한다.
- \_\_del\_\_
- 파이썬은 garbage collection을 하기 때문에 쓸 일은 별로 없다.

#### heap

- 프로그래머 마음대로 메모리를 할당하고, 스코프가 끝나지 않더라도 메모리에서 삭제할 수 있다.
- 할당된 메모리가 삭제되는 것을 보장하지 않음. (memory leak 발생 가능)
- 인터프리터 언어(파이썬 등)는 stack에 메모리에 할당 못함. heap에 할당함.
- private heap : 파이썬이 실행되면서 할당하는 메모리 영역. 이 영역 내부를 나눠서 사용한다.

- 컴파일러 언어는 메모리의 모든 영역을 다 사용 (code, data, heap, stack)

- 파이썬 - compiler - lexer / parser
- 참고 : import ast(lexer에서 parser 넘어가는 중간단계)

##### 과제 : dummy linked list 구현

# stack / queue

### stack

- 위에서 부터 꺼낸다. 
- Last in First out / 후입선출

#### stack ADT

1. push(data) -> None : 마지막에 데이터 추가 (스택에 쌓는다.)
2. pop() -> data : 맨 마지막 데이터 삭제 -> 삭제된 데이터 반환
3. empty() -> bool
4. peek() -> data : 삭제하지 않고 맨 마지막 데이터만 반환

### queue

- First in, First out / 선입선출

#### queue ADT

1. enqueue(data) -> None : insert (맨 뒤에 데이터 삽입)
2. dequeue() -> data : 맨 앞 데이터 삭제하고 삭제하는 데이터 반환
3. empty() -> bool
4. peek() -> data : 삭제하지 않고 맨 앞 데이터 반환

# 후위표기법을 사용한 계산기

- 가정: 모든 피연산자는 1자리 숫자

### 중위표기법

- 우리가 하는 수식
- (2+5)\*3\*(2+1)

### 후위표기법

- 컴퓨터가 계싼하기 쉬은 수식
- 괄호가 없다.;
- 연산자가 뒤로
- 25+3\*21+\*

#### 후위표기법 표시 방법

- 숫자는 무조건 리스트에 append
- 연산자는 가중치를 비교하여 stack이나 리스트에 append
- *, / > +, - > (
- 연산자는 일단 stack에, 다음에 오는 연산자의 가중치가 높을 경우, 기존 연산자 위에 위치
- 다음에 오는 연산자의 가중치가 같을 경우 기존 연산자를 리스트에 append, 지금 연산자는 stack에
- 다음에 오는 연산자의 가중치가 낮을 경우, 기존 stack의 연산자를 리스트에 append.
- stack에 연산자가 여러개 있을 경우 위의 연산자부터 비교.
- ( 는 연산자와 우선순위를 비교하지 않고 무조건 sta	ck에 넣는다.
- ( 위에는 우선순위에 따라 stack에 연산자가 쌓이고 ( 는 우선순위가 낮으므로 ( 다음에 오는 연산자는 ( 위에 쌓인다.
- ) 가 나오면 (가 상쇄되어 없어지고 stack에 쌓여있던 연산자는 위에서부터 순서대로 리스트에 append
- 리스트를 join 하여 완료


# Tree !!!

- 사이클을 이루지 않는 연결 그래프의 일종
- 루트노드 : 가장 상위 노드 (level 0)
- 인터널노드(브랜치노드) : 루트는 아니지만 자식 노드가 있음
- 리프노드(단말노드) : 자식이 없는 마지막 노드
- 엣지(간선, 링크): 노드끼리 연결함
- 서브트리 :자식이 크리를 가짐
- 높이(height) : 루트노드 부터의 높이

### Binary Tree

- 자식노드를 최대 2개만 가지는 트리
- Full Binary Tree(포화이진트리) : 모든 레벨의 노드가 자식을 2개씩을 가지는 트리
- Complete Binary Tree(완전이진트리) : 위에서 아래로, 왼쪽에서 오른쪽으로 노드가 쌓임

### Tree 순회

#### 전위순회

- 부모부터 순회를 시작, 왼쪽에서 오른쪽 (재귀)
- 자식이 더이상 없으면 상위로 올라가 오른쪽 순회

#### 중위순회

- 왼쪽 -> 부모 -> 오른쪽 (재귀)
- 가장 하단의 왼쪽까지 내려가서 순회 시작
- 가장 하단의 왼쪽 > 부모 > 오른쪽

#### 후위순회

- 가장 하단의 왼쪽까지 내려가서 순회 시작
- 가장 하단의 왼쪽 > 오른쪽 > 위로 올라옴 > 오른쪽 가장 하단의 왼쪽 > 오른쪽 > 위로 올라옴



### Binary Search Tree

- 루트(부모)를 중심으로 왼쪽은 루트보다 작은값, 오른쪽은 루트보다 큰값
- 탐색의 BigO = logn
- 추가, 삭제 BigO = logn (추가할때 이어붙임)
- 성능이 좋다.
- 문자일때는 비교함수를 사용하여 기준을 정해준다.

#### 추가

- 추가할 데이터를 루트와 비교하여 루트보다 작으면 왼쪽, 크면 오른쪽
- 이동한 곳에 노드가 있을 경우 다시 값을 비교하여 왼쪽, 오른쪽
- 위치할 곳에 노드가 없을때 그 곳에 추가

#### 삭제

1. 삭제할 노드가 단말노드
2. 삭제할 노드의 자식노드가 하나일때
3. 삭제할 노드의 자식노드가 두개일때

#### BST의 단점

- insert 순서가 1, 2, 3, 4, 5일 경우 링크드리스트와 형태가 같아져 Big O가 n으로 나와서 이진트리의 강점이 사라진다.

#### AVL (균형이진트리)

- 이진트리에 데이터를 insert하면서 효율적인 이진트리 구성으로 만들어준다.
- BST의 단점을 보완
- Black Red.. 도 있음

# Quick Sort

### 단순 알고리즘

- for 문을 2번 사용
- 모두 Big O = n^2

1. bubble sort (버블정렬)
2. insertion sort (삽입정렬)
3. selection sort (선택정렬)

### Divide and Conquer (분할 정복 기법)

- 어려운 문제를 쪼개서(divide) 해결(conquer) 
- 재귀 함수 이용

1. Quick sort (퀵소트)
2. Merge sort (머지소트)

### Quick sort

- 데이터 중에 pivot을 정하고 pivot의 왼쪽에 left, 오른쪽에 right
- left는 오른쪽으로 이동하면서 데이터가 pivot과 크기를 비교하여 pivot보다 같거나 크면 멈춤.
- right는 왼쪽으로 이동하면서 데이터가 pivot과 크기를 비교하여 pivot보다 같거나 작으면 멈춤.
- left와 right의 데이터 교환
- left는 오른쪽으로 1칸 이동, right는 왼쪽으로 1칸 이동
- 반복하다가 left와 right가 교차하면 멈춤

#### Quick sort의 Big O 계산

- n개의 데이터를 절반씩 쪼갠 값이 1이 될때까지
- n * (1/2)^k = 1
- n * logn

##### sort 할때, 함수로 기준을 줄 수 있음

- li.sort(key = lambda x: x%2 == 0)
- 짝수가 뒤로 간다.

##### OOP 참고...

```
class Base:
	var = 10 # 클래스 맴버, 클래스가 가지고 있고 객체들이 공유함
	
	def __init__(self):
		self.data = None # 객체 멤버
```	

##### why i studied full time fir 8 months for a google interview
google interview university

### 언어 종류별 컴파일러

##### 컴파일러 언어

- 컴파일 타임 / 런타임(프로그램이 실행되는 시간)
- 컴파일 타임 : 소스코드를 받아 컴파일러를 커져 컴파일 언어 > 어셈블러를 거쳐 기계어로 변환 ( 요즘은 컴파일러 + 어셈블러)
- 컴파일러를 거쳐 object code가 나옴(목적코드)
- c언어는 컴파일러를 거치면 기계어로 나옴 > 바로 실행
- java는 컴파일러를 거치면 바이트코드로 나옴 > VM > 기계어로 변환 > 실행
- input을 런타임에 받아 결과가 나옴
- 컴파일 타임에 분석이 끝난 코드를 런타임에 실행만 하므로 빠름


##### 인터프리터 언어

- 런타임만 있음.
- 컴파일러가 input과 소스코드를 런타임에 받아 코드를 분석 > 바이트 코드 > VM > 결과
- 런타임 속도가 느림

##### 컴파일

- lexer와 parser로 구성
- lexer : 소스코드를 받아 데이터를 쪼개서 트리(AST)를 구성
- parser : AST를 받아 symbol table을 만들어 바이트코드(c는 기계어)로 만든다.





